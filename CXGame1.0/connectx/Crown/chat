// Rimuovi queste linee di codice:
  if (rows == 3 && cols == 3) {
    depth = 4;
} else if (rows == 4 && cols == 4) {
    depth = 5;
} else {
    depth = 6;
}

// Sostituiscile con:
depth = 4 + (rows + cols) / 4;

.................
public int selectColumn() {
    if (B.isEmpty() || B.getMoves().size() == 1) {
        return cols / 2;
    } else {
        // Resto del tuo codice per la selezione delle mosse
    }
}

....................
// Rimuovi il metodo enemyIsWinning()

// Modifica il metodo alphaBetaPruning():
public int alphaBetaPruning(Node node, int depth, int alpha, int beta, boolean maximizingPlayer) {
    if (depth == 0 || node.isTerminal()) {
        return evaluatePosition();
    }

    if (maximizingPlayer) {
        int maxEval = Integer.MIN_VALUE;
        int bestMove = -1;
        for (int col : node.getValidColumns()) {
            node.makeMove(col, maximizingPlayer);
            int eval = alphaBetaPruning(node, depth - 1, alpha, beta, false);
            node.undoMove();
            if (eval > maxEval) {
                maxEval = eval;
                bestMove = col;
            }
            alpha = Math.max(alpha, eval);
            if (beta <= alpha) {
                break;
            }
        }
        return maxEval;
    } else {
        int minEval = Integer.MAX_VALUE;
        int bestMove = -1;
        for (int col : node.getValidColumns()) {
            node.makeMove(col, maximizingPlayer);
            if (node.isWinning(maximizingPlayer)) {
                node.undoMove();
                return Integer.MIN_VALUE;
            }
            int eval = alphaBetaPruning(node, depth - 1, alpha, beta, true);
            node.undoMove();
            if (eval < minEval) {
                minEval = eval;
                bestMove = col;
            }
            beta = Math.min(beta, eval);
            if (beta <= alpha) {
                break;
            }
        }
        return minEval;
    }
}
..............
// Modifica il metodo evaluateNonePosition():
  public int evaluateNonePosition() {
    int score = 0;

    // Valutazione delle righe
    for (int row = 0; row < rows; row++) {
        int[] rowCells = new int[cols];
        for (int col = 0; col < cols; col++) {
            rowCells[col] = B.getGrid()[row][col];
        }
        score += evaluateLine(rowCells);
    }

    // Valutazione delle colonne
    for (int col = 0; col < cols; col++) {
        int[] colCells = new int[rows];
        for (int row = 0; row < rows; row++) {
            colCells[row] = B.getGrid()[row][col];
        }
        score += evaluateLine(colCells);
    }

    // Valutazione delle diagonali
    for (int offset = -cols + 1; offset < rows; offset++) {
        int[] diagonalCells = new int[Math.min(rows, cols)];
        for (int i = 0; i < diagonalCells.length; i++) {
            int row = i;
            int col = row - offset;
            if (col >= 0 && col < cols) {
                diagonalCells[i] = B.getGrid()[row][col];
            } else {
                diagonalCells[i] = -1;
            }
        }
        score += evaluateLine(diagonalCells);
    }

    for (int offset = -cols + 1; offset < rows; offset++) {
        int[] diagonalCells = new int[Math.min(rows, cols)];
        for (int i = 0; i < diagonalCells.length; i++) {
            int row = rows - 1 - i;
            int col = row - offset;
            if (col >= 0 && col < cols) {
                diagonalCells[i] = B.getGrid()[row][col];
            } else {
                diagonalCells[i] = -1;
            }
        }
        score += evaluateLine(diagonalCells);
    }

    return score;
}

// Modifica il metodo evaluateLine():
private int evaluateLine(int[] line) {
    int score = 0;
    int playerCount = 0;
    int enemyCount = 0;
    int emptyCount = 0;

    for (int cell : line) {
        if (cell == player) {
            playerCount++;
        } else if (cell == enemy) {
            enemyCount++;
        } else {
            emptyCount++;
        }
    }

    if (playerCount > 0 && enemyCount == 0) {
        score += Math.pow(10, playerCount);
    } else if (enemyCount > 0 && playerCount == 0) {
        score -= Math.pow(10, enemyCount);
    }

    return score;
}

...................